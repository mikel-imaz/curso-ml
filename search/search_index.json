{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sobre el curso","text":"<p>Este curso sobre Machine Learning sigue los pasos de la conocida charla de Cassie Kozyrkov disponible en Youtube:  Making Friend with Machine Learning, una presentaci\u00f3n de m\u00e1s de seis horas dirigida a empleados de Google y realizada en 2018.</p> <p>Sin embargo puede seguirlo cualquier persona, no hace falta tener especiales conocimientos.</p> <p>El objetivo es exponer los conceptos generales del Machine Learning<sup>1</sup> y la Inteligencia Artificial. Seg\u00fan su autora, los detalles m\u00e1s t\u00e9cnicos, las ecuaciones matem\u00e1ticas o las l\u00edneas de c\u00f3digo se los puede trabajar uno por su cuenta y adquieren un mayor sentido cuando antes se han asimilado las grandes ideas que hay detr\u00e1s.</p> <p>Me parece un material valioso, y mi intenci\u00f3n ha sido fijar y traducir estos conocimientos sin pretender trasladar por escrito la gracia y el humor que desprende Cassie Kozyrkov es sus presentaciones.</p> <ol> <li> <p>Tambi\u00e9n traducido como Aprendizaje autom\u00e1tico, aunque el t\u00e9rmino Machine Learning parece imponerse.\u00a0\u21a9</p> </li> </ol>"},{"location":"000/","title":"El aprendizaje autom\u00e1tico de las reglas del juego","text":"<p>El siguiente es un ejemplo de un sistema de IA que aprende por s\u00ed mismo a jugar al videojuego Atari Breakout.</p> <p>Sistema sin entrenar: </p> <p>Despu\u00e9s de etapas tempranas del entrenamiento: </p> <p>Despu\u00e9s de etapas avanzadas del entrenamiento: </p> <p>Al sistema se le da el control del joystick y un \u00fanico un mandato: maximizar la puntuaci\u00f3n que obtiene en el menor tiempo posible.</p> <p>As\u00ed que se las tiene que arreglar sin recibir ning\u00fan tipo de instrucci\u00f3n sobre la manera de hacerlo. Y despu\u00e9s de sucesivas etapas de entrenamiento o aprendizaje<sup>1</sup>, encuentra por sus propios medios la forma \u00f3ptima de proceder<sup>2</sup>. Es decir:</p> <p>Aprende autom\u00e1ticamente las reglas</p> <p>Sin que requiera que nadie se las dicte.</p> <p>Esta es la idea que subyace en el aprendizaje autom\u00e1tico o Machine Learning.</p> <ol> <li> <p>Sucesivos intentos, inicialmente err\u00e1ticos, en los que un algoritmo lleva la cuenta de las decisiones que produjeron mejores resultados.\u00a0\u21a9</p> </li> <li> <p>Que en este caso consiste en abrir una v\u00eda de entrada por una de las esquinas para que la bola se cuele en la c\u00e1mara superior y se ponga a rebotar rompiendo los bloques.\u00a0\u21a9</p> </li> </ol>"},{"location":"001_1/","title":"Un etiquetador de cosas","text":"<p>Que las m\u00e1quinas aprendan por su cuenta parece cosa de magia.</p> <p>Adem\u00e1s, los t\u00e9rminos asociados se encuentran de moda:</p> <pre><code>mindmap\n    Root(( ))\n        A(Machine Learning)\n        B(Inteligencia Artificial)\n        C(Redes neuronales)\n        D(Deep Learning)\n        E(LLMs)</code></pre> <p>Pero antes de dejarnos hechizar empecemos por el principio, por la esencia misma del concepto, donde la realidad resulta ser m\u00e1s tangible. </p> <p>Porque Machine Learning es b\u00e1sicamente:</p> <p>Un etiquetador </p> <p>Machine Learning viene a ser un programa que etiqueta cosas.</p> <p>Por ejemplo, etiqueta si un email es spam o no:</p> <p></p> <p>O asigna un precio a cierta cosa definida por sus caracter\u00edsticas:</p> <p></p> <p>O bien asigna una puntuaci\u00f3n a cada posible posici\u00f3n a la que se puede mover el joystick en el juego de Atari:</p> <p></p> <p>O asigna una palabra a una cadena de palabras precedentes en un modelo de lenguaje:</p> <p></p> <p>Una vez asignadas las etiquetas, el programa se encuentra en posici\u00f3n de tomar una decisi\u00f3n. Si las etiquetas las asign\u00f3 correctamente, la decisi\u00f3n que toma en base a ellas a menudo da la impresi\u00f3n de ser (y de hecho es) inteligente.</p> <p>La inteligencia</p> <p>Viene del hecho de tomar decisiones bas\u00e1ndose en el etiquetado previo.</p> <p>Ahora bien, si queremos que un ordenador decida por nosotros, tendremos que hacer que la informaci\u00f3n de entrada (los datos) los convierta en etiquetas a trav\u00e9s de alg\u00fan tipo de \"receta\".</p> <p></p> <p>Y es en la t\u00e9cnica de confeccionar esta receta donde se encuentra la clave que define al Machine Learning.</p>"},{"location":"001_2/","title":"Un cambio de paradigma","text":"<p>\u00bfC\u00f3mo componemos la receta o programa?</p> <p></p> <p>Tradicionalmente, un programador (humano) codificar\u00eda las instrucciones necesarias. Es decir, tecleando proporcionar\u00eda al ordenador las reglas de etiquetado de la informaci\u00f3n, mediante f\u00f3rmulas matem\u00e1ticas, condiciones l\u00f3gicas o lo que sea.</p> <p>El ordenador procesar\u00eda los datos de entrada junto con el programa para proporcionar los resultados.</p> <p></p> <p>En Machine Learning sin embargo ya no elaboramos la receta manualmente. La tarea del programador ya no es codificar, sino proporcionar datos de ejemplo a la m\u00e1quina, la cual, con un algoritmo, confeccionar\u00e1 la receta.</p> <p>Constituye un cambio de paradigma por cuanto es el propio sistema quien aprende las reglas a partir del aprendizaje o entrenamiento con esos datos de ejemplo.</p> <p>Al programa obtenido como resultado de este aprendizaje se le llama modelo, pues representa una realidad que de alguna manera se halla recogida en esos datos.</p> <p></p>"},{"location":"002/","title":"Generalizar para casos nuevos","text":"<p>Consideremos el siguiente ejemplo (inventado) de un plan de tratamiento para un paciente: seg\u00fan el d\u00eda, se especifican las dosis de medicamento a suministrar.</p> <pre><code>d\u00eda     dosis\n1   -&gt;  28 mg\n2   -&gt;  17 mg\n3   -&gt;  92 mg\n4   -&gt;  41 mg\n5   -&gt;   9 mg\n..\n60  -&gt;  86 mg\n</code></pre> <p>La manera de proceder por tanto es sencillamente consultar el d\u00eda y la dosis correspondiente.</p> <p>Ahora bien, supongamos que llegamos al d\u00eda n\u00famero 61. \u00bfCu\u00e1ntos miligramos tocan?</p> <ul> <li>Si no hay patrones en la lista no es posible saberlo.</li> <li>Y si los hay, pero por lo que sea los mismos no son aplicables a partir del d\u00eda 60, entonces tampoco es posible saberlo.</li> </ul> <p>Por tanto, la \u00fanica manera de averiguarlo es buscar en la lista patrones a partir de los cuales se pueda confeccionar una receta, de la cual se pueda deducir lo que corresponde al d\u00eda 61.</p> <p>Para casos de este tipo necesitamos utilizar Machine Learning.</p> <p>En Machine Learning tenemos una tarea primordial:</p> <p>Generalizar</p> <p>Encontrar una respuesta v\u00e1lida en situaciones nuevas.</p> <p>Porque para las situaciones ya conocidas basta con consultar los datos disponibles.</p>"},{"location":"003/","title":"Modelo de clasificaci\u00f3n","text":"<p>Supongamos que durante un tiempo he estado probando diferentes vinos y apuntando si me gustaban o no. Para cada uno de esos vinos anoto tambi\u00e9n su edad y busco en una revista especializada la puntuaci\u00f3n que obtiene por parte de un experto, todo lo cual plasmo en la siguiente gr\u00e1fica:</p> <p></p> <p>A partir de aqu\u00ed, la tarea consiste en adivinar si me va a gustar o no una nueva botella de vino. Es decir, partiendo de su edad y puntuaci\u00f3n, el objetivo es ponerle una de estas dos etiquetas:</p> <p> \"Me gusta\"  \"No me gusta\"    </p> <p>\u00bfAdvertimos alg\u00fan patr\u00f3n en los datos mostrados en la gr\u00e1fica? \u00bfAlg\u00fan criterio que nos permita separar los vinos que me gustan de los que no? \u00bfUna receta que nos facilite hacer las predicciones?</p> <p>No, lo cierto es que no hay ninguna pauta, porque los datos de la gr\u00e1fica han sido colocados de manera aleatoria.</p> <p>Y si resulta que nos parec\u00eda haber entrevisto algo, si hemos empezado a jugar con alg\u00fan tipo de razonamiento que explique la distribuci\u00f3n y en el que podr\u00edamos basarnos para redactar una receta, esa es nuestra imaginativa mente que se pone a elucubrar, fantaseando con cosas que no existen. El enga\u00f1o nos podr\u00eda hacer pensar que hemos dado con una estrategia que podemos explotar, pero claro, las cosas saldr\u00e1n mal cuando la utilicemos con datos nuevos.</p> <p>El Machine Learning puede hacer exactamente lo mismo que nosotros</p> <p>Encontrar patrones que no existen. Y por tanto esto nos conducir\u00e1 a soluciones que no funcionan.</p> <p>La estrategia a emplear para protegernos de este problema ser\u00e1 la misma que deber\u00edamos adoptar para protegernos de nuestras intuiciones humanas: tomar toda aproximaci\u00f3n con cautela y comprobar si lo supuesto funciona con datos nuevos.</p> <p>En la siguiente gr\u00e1fica s\u00ed que hay un patr\u00f3n claro:</p> <p></p> <p>Por lo visto solo me gustan los vinos a\u00f1ejos que hayan obtenido una alta puntuaci\u00f3n.</p> <p>\u00bfC\u00f3mo podr\u00edamos definir este patr\u00f3n? Podr\u00edamos trazar por ejemplo una l\u00ednea recta que hiciera de muro de separaci\u00f3n entre las dos regiones:</p> <p></p> <p>De esta manera conseguimos una receta (un modelo) para que cualquier nuevo dato (botella ) que caiga en una u otra regi\u00f3n quede autom\u00e1ticamente etiquetada como \"Me gusta\" o \"No me gusta\":</p> <p></p> <p>Aunque esa frontera no necesariamente tiene que ser una l\u00ednea recta. Diferentes algoritmos del Machine Learning se diferencian en parte por la forma empleada en estas separaciones, que pueden ser l\u00edneas rectas, cuadr\u00edculas o l\u00edneas curvas:</p> separador algoritmo \\ SVC (Support Vector Classifier) |_ Decision Trees (\u00e1rboles de decisi\u00f3n) ~ Neural Networks (redes neuronales) <p>Una vez seleccionado el algoritmo, el mismo se encargar\u00e1 de ajustar dicha frontera por medio de su forma caracter\u00edstica. Por ejemplo, si se emplea un algoritmo de \u00e1rboles de decisi\u00f3n la partici\u00f3n podr\u00eda tomar el siguiente aspecto:</p> <p></p> <p>Y la receta o modelo, quedar\u00eda as\u00ed:</p> <p></p> <p>Tenemos por tanto dos modelos, pero \u00bfcu\u00e1l de ellos deber\u00edamos utilizar?</p>"},{"location":"004/","title":"Validaci\u00f3n del modelo","text":"<p>Ahora imaginemos que entra una nueva botella de vino que, por su edad y los puntos que ha recibido en las rese\u00f1as, se nos sit\u00faa en el siguiente lugar de la gr\u00e1fica:</p> <p></p> <p>El vino nos gustar\u00e1 o bien no nos gustar\u00e1: uno de los dos modelos har\u00e1 por tanto una predicci\u00f3n err\u00f3nea.</p> <p>\u00bfDice la teor\u00eda algo sobre qu\u00e9 algoritmo resulta m\u00e1s conveniente utilizar?</p> <p>No hay nada escrito sobre esto. Cada caso es diferente y cada algoritmo tiene sus virtudes y sus limitaciones.</p> <p>Entonces, \u00bfc\u00f3mo podemos saber cu\u00e1l es el adecuado? Aqu\u00ed es donde debemos recordar que:</p> <p>Se trata de que funcione con datos nuevos</p> <p>Debe generalizar correctamente m\u00e1s all\u00e1 de los datos con los que hemos construido-entrenado el modelo.</p> <p>Por tanto, para averiguar la idoneidad de uno u otro modelo debemos evaluar los resultados.</p> <p>En nuestro ejemplo resulta que la nueva botella de vino me ha gustado y en consecuencia el modelo que ha dado el resultado correcto es el de la l\u00ednea recta con pendiente, mientras que el de la zona cuadrada ha fallado.</p> <p></p> <p>Pero con un solo dato nuevo no es suficiente. Hay que repetirlo con muchos otros y obtener de ellos los porcentajes de acierto, lo que vendr\u00eda a darnos la precisi\u00f3n de cada uno de los modelos. De manera que:</p> <p>Hay que reservar datos para testear</p> <p>Adem\u00e1s de los datos de aprendizaje o entrenamiento, con los que el algoritmo construye el modelo, es necesario reservar otro conjunto adicional de datos etiquetados para evaluar y finalmente validar los modelos propuestos.</p>"},{"location":"005/","title":"Algoritmos","text":"<p>\u00bfQu\u00e9 es, por lo tanto, Machine Learning? He aqu\u00ed una definici\u00f3n:</p> <p>Machine Learning</p> <p>M\u00e9todo de etiquetado y toma de decisiones que implica buscar por medio de algoritmos patrones en los datos con los que confeccionar modelos que generalicen con datos completamente nuevos.</p> <p>Dentro de esa caja negra que parece el Machine Learning hay por tanto algoritmos.</p> <p></p> <p>He aqu\u00ed algunos de los algoritmos m\u00e1s habituales:</p> <pre><code>mindmap\n    Root(( ))\n        A(Linear Regression)\n        B(k-Means)\n        C(k-NN)\n        D(SVC)\n        E(Decision Trees)\n        F(Random Forests)\n        G(Naive Bayes)\n        H(Logistic Regression)\n        I(Neural Networks)</code></pre> <p>El algoritmo no es m\u00e1s que un conjunto repetitivo de operaciones matem\u00e1ticas que siguiendo un criterio busca maximizar o minimizar un resultado.</p> <p>En Machine Learning normalmente se busca minimizar un error y el criterio es lo que define el tipo algoritmo.</p> <p>Se ver\u00e1 m\u00e1s claro en el siguiente ejemplo.</p>"},{"location":"006/","title":"Regresi\u00f3n lineal","text":"<p>Vayamos con otro ejemplo que servir\u00e1 para introducir la idea que hay detr\u00e1s del algortimo de Regresi\u00f3n Lineal.</p> <pre><code>mindmap\n    Root(( ))\n        A(Linear Regression)</code></pre> <p>Supongamos que vamos a hacer batidos. Los batidos se componen de un yogur, un ingrediente secreto y colorantes. Se bate todo junto en una batidora y se sirve (en nuestro caso se muestra la imagen del batido).</p> <p>Ahora, la propuesta consiste en adivinar la cantidad de calor\u00edas que contiene.</p> <p></p> <p>\u00bf100 calor\u00edas? \u00bf300 calor\u00edas? \u00bf500?</p> <p>Aunque parezca una broma (pues evidentemente no sabemos lo suficiente, solo disponemos de una imagen), la idea de lanzar as\u00ed la cuesti\u00f3n es la de comprobar nuestra disposici\u00f3n. Porque la actitud hacia el Machine Learning no es la del perfeccionismo, la de pensar con cuidado y dar con la respuesta correcta a la primera, sin intentarlo a no ser que estemos seguros de acertar. No, la postura a adoptar es la del ensayo y sondeo. Equiv\u00f3cate porque vas a fallar y lo vas a tener que intentar una y otra vez hasta que finalmente funcione. Y tienes que probar algo para saber qu\u00e9 hacer a continuaci\u00f3n.</p> <p>Los algoritmos de Machine Learning hacen exactamente lo mismo</p> <p>Echan a andar de forma arbitraria, hasta que el criterio que los define les va indicando el camino a seguir.</p> <p>El ingrediente secreto del batido resulta ser 58g de sardinas (\u00a1?), y las calor\u00edas totales del batido nos dicen que son 265.</p> <p>Se prepara otro batido (esperemos que m\u00e1s apetecible). En este el ingrediente secreto es 50g de gofres y la cantidad de calor\u00edas 281.</p> <p>De esta manera se van preparando hasta un total de 15 batidos diferentes, cuyas calor\u00edas se listan a continuaci\u00f3n:</p> <pre><code>265, 281, 207, 148, 240, 154, 176, 290, 167, 245, 176, 259, 251, 503, 191\n</code></pre> <p>Lo cierto es que una ristra de n\u00fameros, as\u00ed puestos, no nos dicen demasiado. De manera que los resumimos calculando la media:</p> <pre><code>Media --&gt; 236,9 calor\u00edas\n</code></pre> <p>Se presenta ahora un nuevo batido, el cual est\u00e1 compuesto por 88g de quiche (\u00a1?) y la pregunta de siempre: \u00bfcu\u00e1ntas calor\u00edas tiene?</p> <p>Ahora, intuitivamente aproximaremos nuestra respuesta a la media. Con esta nueva referencia que nos han proporcionado, el abanico de cifras que antes lanz\u00e1bamos al tunt\u00fan se reducir\u00e1 considerablemente al entorno del promedio.</p> <p>Pues bien, aunque hayamos apostado por cifras en torno a las 237 calor\u00edas, resulta que el batido mostrado de quiche tiene 445 calor\u00edas, de manera que nos hemos desviado bastante en nuestra aproximaci\u00f3n, en concreto el error ha sido de 445 \u2013 237 = 208 calor\u00edas.</p> <p>Por tanto, nos hace falta m\u00e1s informaci\u00f3n. \u00bfAyudar\u00eda disponer del peso en gramos del ingrediente del que se compone el batido?</p> <p>Represent\u00e9moslo en una gr\u00e1fica:</p> <p></p> <p>La idea parece prometedora ya que el peso del ingrediente muestra cierta correspondencia con las calor\u00edas (a m\u00e1s peso, el batido tiende a tener m\u00e1s calor\u00edas).</p> <p>Trazar una l\u00ednea recta nos ayudar\u00e1. Se compone de dos par\u00e1metros, la pendiente y la ordenada en el origen:</p> <pre><code>CALOR\u00cdAS = ordenada + (pendiente * PESO)\n</code></pre> <p>\u00bfQu\u00e9 valores les damos? O lo que es lo mismo: \u00bfd\u00f3nde colocamos la recta?</p> <p> </p> <p>Ninguna de estas rectas parece satisfactoria, y menos a\u00fan la \u00faltima, la de pendiente nula. Y sin embargo, la l\u00ednea horizontal es precisamente el modelo que ten\u00edamos poco antes, cuando sin informaci\u00f3n del peso todo lo que ten\u00edamos era la media.</p> <pre><code>CALOR\u00cdAS = 236,9 + (0 * PESO) =&gt; 236,9\n</code></pre> <p>De esto trata precisamente la b\u00fasqueda de atributos (Feature engineering), de incorporar al modelo variables que ayuden a aproximar la soluci\u00f3n. Y cuando las a\u00f1adimos, de pronto mejoramos el resultado. En la medida en que agregamos informaci\u00f3n relevante, la previsi\u00f3n mejora. Es lo que estamos haciendo desde que tenemos en cuenta el peso del ingrediente del batido.</p> <p>Feature Engineering</p> <p>Incorporaci\u00f3n de variables o atributos que ayuden a construir un modelo que mejore la predicci\u00f3n.</p> <p>De manera que el objetivo ahora es encontrar una l\u00ednea recta que se ajuste lo m\u00e1ximo posible a los datos, es decir, una recta que minimice el error de desviaci\u00f3n del conjunto de los puntos. Podr\u00edamos hacerlo intuitivamente, pero hay que ser preciso, por lo que necesitamos definir matem\u00e1ticamente un par\u00e1metro que mida el \"error de desviaci\u00f3n del conjunto de los puntos con respecto a la recta\".</p> <p>Se utiliza el llamado RMSE (Root Mean Squared Error), un indicador que se calcula de la siguiente manera:</p> <ol> <li>Para cada dato, a su valor se le resta el que aporta la recta en ese punto.</li> <li>Se calcula el cuadrado de dicha diferencia.</li> <li>Se suman as\u00ed todos esos valores cuadrados.</li> <li>Y finalmente se calcula la ra\u00edz cuadrada de dicha suma.</li> </ol> <p>Cada recta propuesta dar\u00e1 como resultado un valor concreto de RMSE. En el caso del modelo de la l\u00ednea horizontal, en el que solo contempl\u00e1bamos el valor medio (sin el peso del ingrediente), si hacemos los c\u00e1lculos obtenemos:</p> <pre><code>CALOR\u00cdAS = 236,9 + (0 * PESO)   ---&gt; RMSE = 84,6\n</code></pre> <p>Sabemos que este resultado es mejorable (pues hay rectas que se ajustan m\u00e1s al conjunto de datos). \u00bfC\u00f3mo podemos dar con aquella que minimice el valor de RMSE?</p> <pre><code>flowchart TD\n    B(Buscar modelo que minimice RMSE)\n    B--&gt;C(A mano)\n    B--&gt;D(Anal\u00edticamente)\n    B--&gt;E(Computacionalmente)</code></pre> <ul> <li>A mano: podr\u00edamos jugar con los par\u00e1metros de pendiente y ordenada hasta encontrarla.</li> <li>Anal\u00edticamente: podr\u00edamos llenar una pizarra empleando f\u00f3rmulas en esos c\u00e1lculos matem\u00e1ticos para encontrar el resultado (un m\u00e9todo de la vieja escuela, \u00bfqui\u00e9n hace este tipo de c\u00e1lculos hoy en d\u00eda?)</li> <li>Computacionalmente: podemos utilizar un algoritmo de optimizaci\u00f3n que haga el trabajo por nosotros y nos d\u00e9 una respuesta vali\u00e9ndonos de la potencia de c\u00e1lculo de un ordenador. Esto es precisamente lo que hace un algoritmo de Machine Learning.</li> </ul> <p>Algoritmo de Machine Learning</p> <p>Soluciona de manera computacional el problema de encontrar el modelo, que es el que satisface un criterio de optimizaci\u00f3n de un par\u00e1metro de error.</p> <p>En el ejemplo de los batidos, ejecutando el algoritmo logramos la siguiente recta:</p> <p></p> <p>Que con sus par\u00e1metros de ordenada (175) y pendiente (1,35) minimiza el valor de RMSE:</p> <pre><code>CALOR\u00cdAS = 175 + (1,35 * PESO)   ---&gt; RMSE = 48,8\n</code></pre> <p>Pues bien, recordando que el batido n\u00famero 16 de Cassie (el de quiche) ten\u00eda 445 calor\u00edas, ahora nos dice que su ingrediente tiene un peso de 88 gramos. Veamos por cu\u00e1nto se desv\u00eda de nuestro modelo.</p> <pre><code>CALOR\u00cdAS = 175 + (1,35 * 88) = 293,8 \u2192 445 \u2013 293,8 \u2248 151\n</code></pre> <p>Se desv\u00eda por un valor de 151 calor\u00edas:</p> <p></p> <p>Vemos que efectivamente el resultado obtenido mejora el anterior:</p> Modelo RMSE Desviaci\u00f3n <code>Valor medio</code> 84,6 208 <code>Regresi\u00f3n lineal simple</code> 48,8 151"},{"location":"007/","title":"Regresi\u00f3n lineal m\u00faltiple","text":"<p>\u00bfPodemos mejorarlo a\u00fan m\u00e1s? Para ello har\u00eda falta m\u00e1s informaci\u00f3n, necesitamos m\u00e1s datos.</p> <p>Pero m\u00e1s datos no en el sentido de m\u00e1s cantidad de ellos, sino en el sentido de otros tipos de informaci\u00f3n, es decir, m\u00e1s atributos, m\u00e1s variables que ayuden a pronosticar mejor.</p> <p>\u00bfPodr\u00eda ayudar si incluimos en el modelo el porcentaje de grasa del ingrediente?</p> <pre><code>CALOR\u00cdAS = ordenada + (pendiente1 * PESO) + (pendiente2 * GRASA%)\n</code></pre> <p>La gr\u00e1fica de puntos resulta tridimensional:</p> <p></p> <p>Ahora, en lugar de una l\u00ednea, lo que hay que aproximar a los puntos en el espacio es un plano que se acerque lo m\u00e1ximo a ellos, minimizando el RMSE igual que antes. Ejecutando el algoritmo que minimiza el error de desviaci\u00f3n, obtenemos el siguiente resultado:</p> <pre><code>CALOR\u00cdAS = 163 + (1,42 * PESO) + (51,9 * GRASA%)   ---&gt; RMSE = 46,9\n</code></pre> <p></p> <p>De manera que al incluir el porcentaje de grasa, doblando el n\u00famero de variables en nuestro modelo, todo lo que obtenemos es esa m\u00ednima mejora, pasando de RMSE = 48,8 a RMSE = 46,9.</p> Modelo RMSE Desviaci\u00f3n <code>Valor medio</code> 84,6 208 <code>Regresi\u00f3n lineal simple</code> 48,8 151 <code>Regresi\u00f3n lineal m\u00faltiple</code> 46,9 143 <p>Quiz\u00e1, despu\u00e9s de todo, el porcentaje de grasa no sea una informaci\u00f3n que contenga gran poder predictivo. Visto esto, quiz\u00e1 nos interese m\u00e1s utilizar el modelo anterior, que era m\u00e1s simple. Aunque siempre podemos probar ambos en un nuevo conjunto de datos para comprobar cu\u00e1l de los dos funciona mejor.</p> <p>\u00bfSe pueden mejorar estos resultados?</p> <p>Un experto en nutrici\u00f3n nos proporcionar\u00eda una buena pista para lograrlo. Nos indicar\u00eda que las calor\u00edas en el batido dependen esencialmente del peso de las grasas, de los carbohidratos y de las prote\u00ednas. As\u00ed que la mejor manera de construir nuestro modelo ser\u00eda apoy\u00e1ndonos en estos tres atributos:</p> <pre><code>CALOR\u00cdAS = ord + (pend1 * GRASA) + (pend2 * CARBOHIDRATOS) + (pend3 * PROTE\u00cdNAS)\n</code></pre> <p>Esta f\u00f3rmula del modelo ya no representar\u00eda un plano, sino un hiperplano. Dibuj\u00e9moslo:</p> <p></p> <p>No, mejor no (no se puede en el espacio tridimensional).</p> <p>En cualquier caso no hay necesidad de dibujarlo, el c\u00e1lculo que hace el algoritmo para minimizar la desviaci\u00f3n funciona de la misma manera independientemente de las dimensiones del modelo.</p> <p>Multidimensionalidad</p> <p>En Machine Learning los conceptos se explican a menudo en dimensiones reducidas para facilitar su explicaci\u00f3n, pero en la realidad esos mismos conceptos funcionan en un conjunto mayor de dimensiones.</p> <p>Estos son los resultados de ordenada y pendientes obtenidos para el hiperplano:</p> <pre><code>Calor\u00edas = 143 + (8,9 * GRASA) + (3,9 * CARBOHIDRATOS) + (4,3 * PROTE\u00cdNAS)\n</code></pre> <p>Lo que el mismo indica es que los carbohidratos aportan aproximadamente 4 calor\u00edas por gramo, las prote\u00ednas andan tambi\u00e9n en ese rango, y la grasa aporta 9 calor\u00edas por gramo. El valor de ordenada en el origen revela las calor\u00edas que aporta el yogur (143: son las calor\u00edas de un batido cuyo ingrediente \u00fanico sea agua).</p> <p>Ve\u00e1mos los resultados en la tabla resumen:</p> Modelo RMSE Desviaci\u00f3n <code>Valor medio</code> 84,6 208 <code>Regresi\u00f3n lineal simple</code> 48,8 151 <code>Regresi\u00f3n lineal m\u00faltiple</code> 46,9 143 <code>Hiperplano</code> 3,8 4 <p>\u00a1Este \u00faltimo es un resultado muy bueno!</p> <p>Estamos cometiendo un error promedio de unas 3,8 calor\u00edas y la desviaci\u00f3n respecto al batido de quiche es de tan solo 4 calor\u00edas.</p> <p>Contar con la ayuda de un nutricionista result\u00f3 crucial para incorporar en los datos el peso de las grasas, de los carbohidratos y de las prote\u00ednas.</p> <p>El conocimiento en la materia</p> <p>Es fundamental para definir los atributos o variables que contengan informaci\u00f3n predictiva de calidad con la que construir el modelo.</p> <p>A dicho proceso de definici\u00f3n de atributos o variables se le conoce con el nombre de Feature Engineering.</p> <p>Por regla general, en los resultados obtenidos en el Machine Learning suelen ser m\u00e1s decisivos aspectos como la calidad de los datos y los atributos que representan, antes que el tipo de algoritmo que se emplee en la consecuci\u00f3n del modelo.</p>"},{"location":"009/","title":"\u00bfQu\u00e9 es entonces la IA?","text":"<p>El t\u00e9rmino Inteligencia Artificial surgi\u00f3 a finales de los a\u00f1os 1950 y entonces significaba algo diferente de lo que hoy se entiende por Inteligencia Artificial.</p> <p>En aquel entonces era todo aquello que la tecnolog\u00eda promet\u00eda en cuanto a inteligencia de las m\u00e1quinas. Los a\u00f1os finales de la d\u00e9cada de los cincuenta e inicios de los sesenta fueron ilusionantes en este sentido: los primitivos ordenadores de aquel tiempo aprendieron a jugar a las damas y resolv\u00edan problemas l\u00f3gicos. Era asombroso. Se lanzaron las campanas al vuelo y predijeron que en pocos a\u00f1os la IA superar\u00eda al ser humano.</p> <p>Se equivocaron, fue un espejismo. La tecnolog\u00eda era a\u00fan rudimentaria y no era posible llevar a cabo las ideas que se planteaban sobre el papel. Las expectativas se desinflaron, lo cual llev\u00f3 a un periodo de tiempo conocido como \"Invierno de la IA\", en el que se congelaron las inversiones y las investigaciones en este campo.</p> <p>Hubo sucesivos altibajos, periodos en los que parec\u00eda que ahora s\u00ed, pero luego los proyectos no cuajaban y se volv\u00edan a defraudar las expectativas. Hasta el punto de que Inteligencia Artificial se volvi\u00f3 un t\u00e9rmino con mala prensa, algo poco serio m\u00e1s relacionado con la ciencia ficci\u00f3n y la cultura popular cuyo uso se trat\u00f3 de evitar a la hora de referirse a los avances en este terreno, para no ahuyentar a potenciales inversores.</p> <p>Los mayores progresos fueron llegando de la mano del Machine Learning. Hasta entonces la inteligencia se hab\u00eda introducido en los ordenadores a trav\u00e9s de instrucciones definidas de forma expl\u00edcita, es decir, mediante la forma cl\u00e1sica de programar un ordenador. Sin embargo, con Machine Learning era la propia m\u00e1quina quien aprend\u00eda las caracter\u00edsticas del sistema a partir de datos de ejemplo suministrados. Constitu\u00eda una gran ventaja a la hora de lograr los par\u00e1metros de sistemas complejos.</p> <p>Los algoritmos de Machine Learning fueron implement\u00e1ndose de forma creciente en aplicaciones reales con la llegada de Internet y la mayor disponibilidad de datos. Sectores como el financiero y el del comercio electr\u00f3nico fueron incorpor\u00e1ndolos con \u00e9xito. Se automatizaron sistemas de recomendaci\u00f3n, detecci\u00f3n, segmentaci\u00f3n, previsi\u00f3n y dem\u00e1s tareas, aumentando as\u00ed la inteligencia de las empresas y los negocios.</p> <p>Sin embargo, segu\u00edan pendientes de ser resueltos multitud de otras aplicaciones m\u00e1s complejas y habitualmente m\u00e1s asociadas con las capacidades de la inteligencia humana. Por ejemplo, la capacidad de mantener una conversaci\u00f3n que suene natural, como con una persona. O la de identificar elementos en una imagen.</p> <p>Pensemos en este cometido, el de recibir la informaci\u00f3n por medio de una imagen y dar como resultado su identificaci\u00f3n:</p> <p></p> <p>\u00bfC\u00f3mo hacer que un ordenador solucione esta tarea? La forma tradicional de hacerlo no parece sencilla. Habr\u00eda que definir exactamente qu\u00e9 hacer con cada p\u00edxel de la imagen y despu\u00e9s programar esas instrucciones en el ordenador, una a una. \u00abAs\u00ed es como debes analizar los p\u00edxeles que te doy y as\u00ed es c\u00f3mo debes deducir si es un gato o no\u00bb. Se ha de escribir una receta que adem\u00e1s funcione en todas circunstancias: \u00bffuncionar\u00e1 con una imagen completamente diferente de un gato? Parece realmente complicado escribir estas reglas.</p> <p>Para nosotros los humanos sin embargo es sencillo. Nuestro cerebro recibe la informaci\u00f3n a trav\u00e9s de los sentidos (imagen de un gato), y obtenemos la respuesta como por arte de magia (\u00ab\u00a1gato!\u00bb). Lo hacemos sin saber c\u00f3mo lo hacemos. Sencillamente lo sabemos. Hacemos algo con esos p\u00edxeles en nuestra mente, pero no sabemos qu\u00e9 es eso que estamos haciendo. No tenemos ni idea de c\u00f3mo funciona. No es de extra\u00f1ar que no sepamos expresarlo y definir las reglas a un ordenador.</p> <p>La teor\u00eda de las redes neuronales era conocida desde los a\u00f1os cincuenta, aunque apenas se hab\u00eda puesto en pr\u00e1ctica. Algoritmos matem\u00e1ticos basados en una estructura de nodos interconectados (como las neuronas de nuestro cerebro) capaces de aprender a solucionar problemas a base de un entrenamiento con datos en los que se busca optimizar el resultado. Sistemas tremendamente flexibles, capaces de abordar los problemas m\u00e1s complejos, pero con dos requerimientos impepinables:</p> <ol> <li>Una gran capacidad de computaci\u00f3n de los ordenadores.</li> <li>Una gran cantidad de datos para entrenarlos.</li> </ol> <p>A partir de la d\u00e9cada de 2010 se empez\u00f3 a disponer de ambos recursos en cantidades suficientes.</p> <p>Y con el despegue de esta tecnolog\u00eda, los algoritmos basados en redes neuronales evolucionaron hacia la sofisticaci\u00f3n y se hicieron conocidos como modelos de Deep Learning (aprendizaje profundo). En ellos, entre las entradas suministradas y la salida producida, lo que hacen las capas intermedias de nodos es desconocido. Estos sistemas funcionan como una caja negra dentro de la cual no se sabe con qu\u00e9 criterios se valoran las se\u00f1ales, solo se sabe que dan un resultado deseado como fruto del aprendizaje al que han sido sometidos:</p> <p></p> <p>Ni m\u00e1s ni menos que lo que sucede con la mente humana. Este hecho, junto con los paralelismos de los nodos-neuronas y el hecho de que con ellos se pueda empezar a dar respuesta a problemas de verdadera inteligencia humana, hizo que se recuperara t\u00e9rmino Inteligencia Artificial, ahora ya asociado a Deep Learning.</p> <p></p> <p>El cambio de paradigma que se hab\u00eda producido con Machine Learning y el aprendizaje autom\u00e1tico a partir de los datos, con la Inteligencia Artificial moderna se vuelve norma. Al fin y al cabo, en el llamado Machine Learning cl\u00e1sico los modelos son interpretables y a\u00fan se puede seguir la pista anal\u00edtica de lo que est\u00e1n haciendo. Sin embargo, las tripas de la Inteligencia Artificial son poco menos que inescrutables, y con ellos la \u00fanica forma de hablar es la de darles de comer ejemplos.</p> <p>Esto tambi\u00e9n sucede entre los seres humanos. Cuando las personas nos comunicamos los unos con los otros, por ejemplo para que alguien haga algo por nosotros, tenemos la posibilidad de dar instrucciones precisas. Pero m\u00e1s habitualmente, y sobre todo cuando definirlo resulta dif\u00edcil (o imposible), lo que hacemos es dar ejemplos. \u00abMira aqu\u00ed estos ejemplos, quiero que hagas uno como estos, y luego tu ya te arreglar\u00e1s\u00bb. As\u00ed es como lo hacemos a menudo.</p> <p>Pues bien, la Inteligencia Artificial es esta herramienta que nos permite comunicarnos con las m\u00e1quinas a base de darles ejemplos, de esta manera tan natural para nosotros que sin embargo hasta hace poco nos estaba vedada con respecto a los ordenadores. Como los problemas m\u00e1s complejos de la realidad frecuentemente no admiten ser definidos de manera precisa, esta nueva forma de hacer que los ordenadores hagan cosas por nosotros resulta una gran liberaci\u00f3n.</p> <p>Por decirlo de una manera quiz\u00e1 m\u00e1s po\u00e9tica, la Inteligencia Artificial permite automatizar lo inefable y por ello abre la v\u00eda a solucionar toda una nueva gama de tareas que antes era impensable acometer.</p>"},{"location":"010/","title":"\u00bfY por qu\u00e9 ahora?","text":"<p>\u00bfPor qu\u00e9 ahora la ciencia ficci\u00f3n se convierte en realidad?</p> <p>Porque aunque las ideas que sustentan esta tecnolog\u00eda llevan existiendo bastante tiempo, solamente en tiempos recientes se ha dispuesto de datos en abundancia y de acceso a potencia computacional elevada a un coste asumible.</p> <p>Lo cual ha estimulado el desarrollo de algoritmos todav\u00eda m\u00e1s sofisticados que requieren a su vez de m\u00e1s datos a\u00fan y de m\u00e1s potencia de computaci\u00f3n, llev\u00e1ndonos todo ello, ahora s\u00ed, a la era de la Inteligencia Artificial.</p> <pre><code>flowchart TD\n    C(Abundancia de datos)--&gt;B(Advenimiento de la IA)\n    D(Potencia de computaci\u00f3n)--&gt;B\n    E(Algoritmos sofisticados)--&gt;B</code></pre> <p> \u00a0 DATOS</p> <p>Lo que sobre todo hac\u00eda falta para que toda esta revoluci\u00f3n tecnol\u00f3gica echara a andar, era una buena cantidad de datos etiquetados.</p> <p>Durante sus primeros a\u00f1os de vida, a los ni\u00f1os sus padres y educadores les ense\u00f1an con innumerables ejemplos sobre el mundo que les rodea. A las m\u00e1quinas es lo que les faltaba, alguien les etiquetara el mundo con ejemplos.</p> <p>Diferentes proyectos echaron a andar cuyo objetivo fue etiquetar correctamente cientos de miles de im\u00e1genes y textos provenientes de internet, una tarea repetitiva y tediosa ejecutada por miles de trabajadores de baja cualificaci\u00f3n (aunque humanamente inteligentes, pues una m\u00e1quina no lo pod\u00eda hacer) en el formato conocido como Mechanical Turk.</p> <p> \u00a0 ALGORITMOS</p> <p>Los algoritmos que han permitido toda esta revoluci\u00f3n son los basados en la arquitectura de redes neuronales.</p> <p>Las redes neuronales artificiales son b\u00e1sicamente muchas capas de transformaciones matem\u00e1ticas. Como resultado se obtienen modelos tremendamente flexibles, recetas que, en caso de existir patrones, encuentran la manera de extraerlos diferenciando las etiquetas correspondientes, por muy subyacente que se encuentre dicha informaci\u00f3n dentro de la intrincada masa de datos.</p> <p> \u00a0 COMPUTACI\u00d3N</p> <p>Hacia 2010, algunos investigadores se dieron cuenta de las transformaciones matem\u00e1ticas de las redes neuronales se pod\u00edan ejecutar de manera \u00f3ptima en un hardware que hab\u00eda sido desarrollado tiempo atr\u00e1s para una tarea completamente diferente: los videojuegos.</p> <p>En efecto, las GPU (Graphical Processing Unit) eran ideales, pues aunque hab\u00edan sido concebidas para procesar im\u00e1genes a gran velocidad, resulta que su arquitectura orientada a las operaciones en paralelo se ajustaba perfectamente a los c\u00e1lculos que hac\u00edan las redes neuronales. De manera que descubrieron una poderosa unidad de computaci\u00f3n por un precio de mercado reducido y esto contribuy\u00f3 a expandirse y a acelerar el desarrollo de esta tecnolog\u00eda.</p>"},{"location":"toc/","title":"Referencia","text":"<p>Conceptos b\u00e1sicos</p> <p>MFML 000 \u2014 Welcome<sup>1</sup> Las reglas del juego MFML 001 \u2014 What is machine learning? Etiquetador de cosas Un cambio de paradigma MFML 002 \u2014 Why use machine learning? Generalizar MFML 003 \u2014 How does machine learning work?  Modelo de clasificaci\u00f3n MFML 004 \u2014 How to test ML  Validaci\u00f3n del modelo MFML 005 \u2014 What\u2019s inside the black box? Algoritmos MFML 006 \u2014 Simple linear regression  Regresi\u00f3n lineal MFML 007 \u2014 Multiple linear regression  Regresi\u00f3n lineal m\u00faltiple MFML 008 \u2014 Feature engineering MFML 009 \u2014 What is AI? \u00bfQu\u00e9 es entonces la IA? MFML 010 \u2014 Why did we wait so long for AI? \u00bfY por qu\u00e9 ahora? MFML 011 \u2014Algorithms, data, and compute </p> <p> </p> <p>In Practice</p> <p>MFML 012 \u2014 Real applications MFML 013 \u2014 How to find good AI use cases MFML 014 \u2014 Human creativity in AI MFML 015 \u2014 How Do GANs work? MFML 016 \u2014 Why trust AI? MFML 017 \u2014 Explainability and AI MFML 018 \u2014 Intro to training, validation, and testing MFML 019 \u2014 How to avoid machine learning pitfalls MFML 020 \u2014 Decision Intelligence MFML 021 \u2014 Why do businesses fail at machine learning? MFML 022 \u2014 Skilled decision-makers MFML 023 \u2014 Reliable or unreliable? MFML 024 \u2014 Preventable disasters MFML 025 \u2014 Wish responsibly MFML 026 \u2014 AI is a team sport! MFML 027 \u2014 Our AI future  </p> <p> </p> <p>The 12 Steps of AI</p> <p>Step 0: Find an application where ML is useful MFML 028 \u2014 The 12 steps of AI MFML 029 \u2014 Where to start with applied AI? MFML 030 \u2014 Classification vs regression MFML 031 \u2014 Instances, features, and targets MFML 032 \u2014 Supervised learning MFML 033 \u2014 Unsupervised learning MFML 034 \u2014 Semi-supervised learning MFML 035 \u2014 Reinforcement learning MFML 036 \u2014 What on earth is data science? MFML 037 \u2014 Data science flowchart MFML 038 \u2014 Don\u2019t forget data!  </p> <p>Step 1: Define your objective MFML 039 \u2014 What is \u201cgood behavior\u201d for AI? MFML 040 \u2014 False positives and true negatives MFML 041 \u2014 Confusion matrix MFML 042 \u2014 Performance metrics MFML 043 \u2014 Ground truth MFML 044 \u2014 Precision vs recall MFML 045 \u2014 What is optimization? MFML 046 \u2014 Loss functions MFML 047 \u2014 Setting launch criteria  </p> <p>Step 2: Get your data MFML 048 \u2014 Data engineering  </p> <p>Step 3: Split your data MFML 049 \u2014 The danger of overfitting MFML 050 \u2014 Should you care about underfitting? MFML 051 \u2014 The importance of data splitting  </p> <p>Step 4: Explore some data MFML 052 \u2014 Exploratory data analysis (EDA)  </p> <p>Step 5: Prepare your tools MFML 053 \u2014 How to select an AI algorithm MFML Part 4 \u2014 Guide to AI algorithms  </p> <p>Step 6: Train your models MFML 054 \u2014 Is training an AI system easy? MFML 055 \u2014 A dataset\u2019s idea shape MFML 056 \u2014 How to speed up your ML/AI training phase MFML 057 \u2014 Statistics versus \u201cstatistics\u201d MFML 058 \u2014 When your machine learning project takes forever MFML 059 \u2014 Regularization MFML 060 \u2014 Features you should never use in AI MFML 061 \u2014 Can you skip the training phase in AI?  </p> <p>Step 7: Tune and debug your models MFML 062 \u2014 Debugging your machine learning model MFML 063 \u2014 Hyperparameter tuning MFML 064 \u2014 What is a holdout set and how do you use it? MFML 065 \u2014 Understanding k-fold cross-validation MFML 066 \u2014 Advanced AI debuggin MFML 067 \u2014 What if you skip debugging?  </p> <p>Step 8: Validate your model MFML 068 \u2014 What to do when model validation fails MFML 069 \u2014 Model validation done right MFML 070 \u2014 Validation roulette  </p> <p>Step 9: Test your model MFML 071 \u2014 What\u2019s the difference between testing and validation MFML 072 \u2014 The 12 steps of statistics MFML 073 \u2014 Interpreting AI test output MFML 074 \u2014 Understanding p-values MFML 075 \u2014 Statistical significance MFML 076 \u2014 What should you do if testing fails MFML 077 \u2014 The importance of testing  </p> <p>Step 10: Build your ML system MFML 078 \u2014 Productionization MFML 079 \u2014 Repurposing data safely MFML 080 \u2014 Solving AI latency problems MFML 081 \u2014 How often should you retrain your AI system? MFML 082 \u2014 The training-serving skew MFML 083 \u2014 Be careful with chained models MFML 084 \u2014 Making tiny changes to AI code MFML 085 \u2014 When your AI model fails retesting MFML 086 \u2014 The danger of the long tail in AI MFML 087 \u2014 How to catch outliers and AI failures MFML 088 \u2014 AI safety and policy layers  </p> <p>Step 11: Make launch decision MFML 089 \u2014 Live traffic experiments  </p> <p>Step 12: Monitor and maintain MFML 090 \u2014 Monitoring your AI system MFML 091 \u2014 AI system maintenance  </p> <p> </p> <p>Introduction to Algorithms</p> <p>Menu MFML 092 \u2014 Opening the black box  </p> <p>Unsupervised Learning MFML 093 \u2014 Clustering and k-means  </p> <p>Lazy Learning MFML 094 \u2014 Lazy learning and k-NN MFML 095 \u2014 The curse of dimensionality  </p> <p>Linear Classifiers MFML 096 \u2014 What are perceptrons? MFML 097 \u2014 Maximal margin classifiers MFML 098 \u2014 What are support vectors? MFML 099 \u2014 SVMs and the kernel trick  </p> <p>Decision Trees and Random Forests MFML 100 \u2014 What is a decision tree? MFML 101 \u2014 XAI and the interpretability debate MFML 102 \u2014 Decision trees and SVMs compared MFML 103 \u2014 Boosted Aggregation a.k.a. Bagging MFML 104 \u2014 What is a random forest?  </p> <p>Ensembles MFML 105 \u2014 Ensemble models  </p> <p>Naive Bayes MFML 106 \u2014 Introduction to Bayes\u2019 Rule MFML 107 \u2014 What\u2019s so naive about Naive Bayes?  </p> <p>Regression Models MFML 006 \u2014 Simple linear regression MFML 007 \u2014 Multiple linear regression MFML 008 \u2014 Feature engineering  MFML 108 \u2014 What do all regression models have in common? MFML 109 \u2014 When should you use linear regression? MFML 110 \u2014 Logistic regression MFML 111 \u2014 What are all those sigmoid functions for? MFML 112 \u2014 How to do ranking at scale  </p> <p>Deep Learning MFML 113 \u2014 Introduction to deep learning MFML 114 \u2014 What\u2019s inside a neural network? MFML 115 \u2014 Using AI for automatic feature extraction MFML 116 \u2014 Understanding the components of your neural network MFML 117 \u2014 Backpropagation MFML 118 \u2014 Gotchas, pros, and cons of deep learning MFML 119 \u2014 Neural network architecture MFML 120 \u2014 When to use neural networks  </p> <ol> <li> <p>El tachado indica que el contenido del v\u00eddeo ya est\u00e1 cubierto en su versi\u00f3n de este curso.\u00a0\u21a9</p> </li> </ol>"}]}